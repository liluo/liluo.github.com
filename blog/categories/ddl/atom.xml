<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DDL | 落]]></title>
  <link href="http://liluo.org/blog/categories/ddl/atom.xml" rel="self"/>
  <link href="http://liluo.org/"/>
  <updated>2016-01-03T16:15:14+08:00</updated>
  <id>http://liluo.org/</id>
  <author>
    <name><![CDATA[落]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[非 DBA 也要勇敢的 Online(!) DDL]]></title>
    <link href="http://liluo.org/blog/2015/12/mysql-online-ddl/"/>
    <updated>2015-12-30T14:14:00+08:00</updated>
    <id>http://liluo.org/blog/2015/12/mysql-online-ddl</id>
    <content type="html"><![CDATA[<p>目前我司没有专职 DBA，所以 Online DDL 需要自己动手。最近操作了几次不同数量级（单表 5 million, 20 million, 80 million）的 Online DDL，这里做下记录，希望这些数据能够对其他和我一样非 DBA 的同学提供点儿参考价值。</p>

<!-- more -->


<h3>Production Environments</h3>

<p><code>bash
Database: MySQL
Version: 5.6.19
Storage Engine: InnoDB
Migrate Tool: Active Record Migrations(Ruby on Rails)
</code></p>

<h3>Round 1（5 million）</h3>

<p>第一个回合是给 500W+ 记录的表增加两个字段和一个索引：</p>

<p><code>bash
ALTER TABLE `table` ADD COLUMN `foo` INT DEFAULT 0;
ALTER TABLE `table` ADD COLUMN `bar` DATETIME DEFAULT NULL;
ALTER TABLE `table` ADD INDEX `index_table_on_bar` (`bar`);
</code></p>

<p>首次操作这么“大规模”（让 DBA 们贱笑了）的 Online(!!!) DDL 内心是有点小复杂……</p>

<p>当时的心理预期是 10 分钟，但是结果却很乐观：</p>

<p><code>bash
== AddFooToTable: migrating - Shard: master =============
-- add_column(:table, :foo, :integer, {:default=&gt;0})
-&gt; 95.8153s
== AddFooToTable: migrated (95.8155s) - Shard: master ===
== AddBarToTable: migrating - Shard: master =============
-- add_column(:table, :bar, :datetime)
-&gt; 94.1172s
-- add_index(:table, :bar)
-&gt; 10.6757s
== AddBarToTable: migrated (104.7929s) -- Shard: master =
</code></p>

<h3>Round 2（20 million）</h3>

<p>第二回合是 2000W+ 记录的表，更改其中一字段类型(varchar -> integer)：</p>

<p><code>bash
ALTER TABLE `table` MODIFY `foo` INTEGER;
</code></p>

<p>有了上次的经历之后，这次已然是云淡风轻，耗时也不出意外：</p>

<p><code>bash
== ChangeFooTypeInTable: migrating - Shard: master ==============
-- change_column(:table, :foo, :integer)
-&gt; 513.9101s
== ChangeFooTypeInTable: migrated (513.9102s) - Shard: master ===
</code></p>

<h3>Round 3（80 million）</h3>

<p>第三回合是 8000W+ 记录的表，增加一个字段和一个索引：</p>

<p><code>bash
ALTER TABLE `table` ADD COLUMN `foo` DATETIME DEFAULT NULL;
ALTER TABLE `table` ADD INDEX `index_table_on_foo` (`foo`);
</code></p>

<p>这次的耗时远超预期……因为要避开高峰时段在凌晨操作，我是靠着 Xbox 的《Just Dance》和《Sports Rivals》才勉强坚持住。</p>

<p>好吧，来看一下耗时：</p>

<p><code>bash
== 20151228112810 AddFooToTable: migrating - Shard: master ===============
-- add_column(:table, :foo, :datetime)
-&gt; 4313.0770s
-- add_index(:table, :foo)
-&gt; 248.9602s
== 20151228112810 AddFooAtToTable: migrated (4562.0374s) - Shard: master =
</code></p>

<h3>其他</h3>

<ul>
<li><p>如果使用 MySQL 的 master-slave 模式, 同步到 slave 大概需要花费同样的时间（这块儿我们没有做特别具体的统计，只是 master 完成后人工检查 slave 情况得出的一个比较粗暴的结论）。</p></li>
<li><p>MySQL 官方文档：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html">Overview of Online DDL</a></p></li>
</ul>


<p><strong>END</strong></p>
]]></content>
  </entry>
  
</feed>
